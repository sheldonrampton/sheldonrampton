<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>views_query Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>views_query Class Reference</h1><!-- doxytag: class="views_query" -->
<p>
<a href="classviews__query-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#fa6130b3c7d7a5a5edb03069bb7d8995">views_query</a> ($base_table= 'node', $base_field= 'nid')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#cb3f17ef4ae3d80a44ee7b6962165247">set_distinct</a> ($value=TRUE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#b669461223ddaae12248f28b4ccfb525">set_count_field</a> ($table, $field, $alias=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#83e8dfa6c88442e0f34b00d467f3b35e">set_header</a> ($header)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#db0faccc1a266ce414a3dc58f4de22d0">add_relationship</a> ($alias, $join, $base, $link_point=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#52cdfc5396008424c4c232cca1a8f8bb">add_table</a> ($table, $relationship=NULL, $join=NULL, $alias=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#0ed3905be8cddfdbde96a39569686bcb">queue_table</a> ($table, $relationship=NULL, $join=NULL, $alias=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60d0c1c4304248692893fda0a3281af3"></a><!-- doxytag: member="views_query::mark_table" ref="60d0c1c4304248692893fda0a3281af3" args="($table, $relationship, $alias)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>mark_table</b> ($table, $relationship, $alias)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#78c615fc19826e8a640ab27874e2fdaf">ensure_table</a> ($table, $relationship=NULL, $join=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#2571123727140d93d8ee3357968a626e">ensure_path</a> ($table, $relationship=NULL, $join=NULL, $traced=array(), $add=array())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#9eb7d6626aa24ae83d922cc59682318c">adjust_join</a> ($join, $relationship)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#de77e3ef670bde3a2eacf8d73f5859fa">get_join_data</a> ($table, $base_table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#e4b476ae432575dab501ed30b5421b7d">get_table_info</a> ($table)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#7d073b7dde56cfb8c0e97696b50d5da4">add_field</a> ($table, $field, $alias= '', $params=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#f36b1f088b20f1d98d23dbf49ee68e97">clear_fields</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#7c803401b485f379a93688efd7aa2886">set_where_group</a> ($type= 'AND', $group=NULL, $where= 'where')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#8dfc6f355b29f697401f0dc7f7aa82a1">set_group_operator</a> ($type= 'AND')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#88733d15379fa820cc588b11a298a3af">add_where</a> ($group, $clause)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#db01fc3898236d7f3c9134cd5971ff67">add_having</a> ($group, $clause)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#d6ad02de9d393f27da6b998ff54a91ec">add_orderby</a> ($table, $field, $order, $alias= '')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#089b7eab81ec9cb4b24aa489ff4ac448">add_groupby</a> ($clause)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#2048d9a8aefd815a30833b26f6070fb2">condition_sql</a> ($where= 'where')</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#50460c7856f25847d361a45a6c1d4b69">query</a> ($get_count=FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#caf5f2625a89d8b29e6d9ad6127d1b17">get_where_args</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#209ff1ef3916cfbdfc70560e567a9cc0">$table_queue</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#cec1482297b871cac1fddcef0a0e8ab1">$tables</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#deed5f6f13a7d105ada7c1329c3169d6">$relationships</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#2654e7db457f1b7ec34ca1ac3345fc83">$where</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#a63f09e8b8810660bbc0c480f763c8a7">$having</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#a290c68d4f2fd7ccc73219ce5e57d0f7">$group_operator</a> = 'AND'</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#03a5999bf0fcd2bd5a51dfea6c78ebdb">$orderby</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#9e680695793121eceb7da5e5f8f0105a">$groupby</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#8c8dc5000b07e8a5ade3691ddabecbc3">$header</a> = array()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviews__query.html#48c0f8c68da79257d96109835021305c">$distinct</a> = FALSE</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Object used to create a SELECT query. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7d073b7dde56cfb8c0e97696b50d5da4"></a><!-- doxytag: member="views_query::add_field" ref="7d073b7dde56cfb8c0e97696b50d5da4" args="($table, $field, $alias= '', $params=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_field           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em> = <code>''</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a field to the query table, possibly with an alias. This will automatically call ensure_table to make sure the required table exists, *unless* $table is unset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The table this field is attached to. If NULL, it is assumed this will be a formula; otherwise, ensure_table is used to make sure the table exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$field</em>&nbsp;</td><td>The name of the field to add. This may be a real field or a formula. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$alias</em>&nbsp;</td><td>The alias to create. If not specified, the alias will be $table_$field unless $table is NULL. When adding formulae, it is recommended that an alias be used.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>$name The name that this field can be referred to as. Usually this is the alias. </dd></dl>

</div>
</div><p>
<a class="anchor" name="089b7eab81ec9cb4b24aa489ff4ac448"></a><!-- doxytag: member="views_query::add_groupby" ref="089b7eab81ec9cb4b24aa489ff4ac448" args="($clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_groupby           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>clause</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a simple GROUP BY clause to the query. The caller is responsible for ensuring that the fields are fully qualified and the table is properly added. 
</div>
</div><p>
<a class="anchor" name="db01fc3898236d7f3c9134cd5971ff67"></a><!-- doxytag: member="views_query::add_having" ref="db01fc3898236d7f3c9134cd5971ff67" args="($group, $clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_having           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>clause</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a simple HAVING clause to the query. The caller is responsible for ensuring that all fields are fully qualified (TABLE.FIELD) and that the table and an appropriate GROUP BY already exist in the query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$group</em>&nbsp;</td><td>The HAVING group to add these to; groups are used to create AND/OR sections. Groups cannot be nested. Use 0 as the default group. If the group does not yet exist it will be created as an AND group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$clause</em>&nbsp;</td><td>The actual clause to add. When adding a having clause it is important that all tables are addressed by the alias provided by add_table or ensure_table and that all fields are addressed by their alias wehn possible. Please use d and s for arguments. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A number of arguments as used in <a class="el" href="database_8mysql-common_8inc.html#9e096321b86945d128746ac7bedce8f3">db_query()</a>. May be many args or one array full of args. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d6ad02de9d393f27da6b998ff54a91ec"></a><!-- doxytag: member="views_query::add_orderby" ref="d6ad02de9d393f27da6b998ff54a91ec" args="($table, $field, $order, $alias= '')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_orderby           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em> = <code>''</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an ORDER BY clause to the query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The table this field is part of. If a formula, enter NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$field</em>&nbsp;</td><td>The field or formula to sort on. If already a field, enter NULL and put in the alias. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$order</em>&nbsp;</td><td>Either ASC or DESC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$alias</em>&nbsp;</td><td>The alias to add the field as. In SQL, all fields in the order by must also be in the SELECT portion. If an $alias isn't specified one will be generated for from the $field; however, if the $field is a formula, this alias will likely fail. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="db0faccc1a266ce414a3dc58f4de22d0"></a><!-- doxytag: member="views_query::add_relationship" ref="db0faccc1a266ce414a3dc58f4de22d0" args="($alias, $join, $base, $link_point=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_relationship           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>link_point</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A relationship is an alternative endpoint to a series of table joins. Relationships must be aliases of the primary table and they must join either to the primary table or to a pre-existing relationship.<p>
An example of a relationship would be a nodereference table. If you have a nodereference named 'book_parent' which links to a parent node, you could set up a relationship 'node_book_parent' to 'node'. Then, anything that links to 'node' can link to 'node_book_parent' instead, thus allowing all properties of both nodes to be available in the query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$alias</em>&nbsp;</td><td>What this relationship will be called, and is also the alias for the table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$join</em>&nbsp;</td><td>A <a class="el" href="classviews__join.html">views_join</a> object (or derived object) to join the alias in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$base</em>&nbsp;</td><td>The name of the 'base' table this relationship represents; this tells the join search which path to attempt to use when finding the path to this relationship. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$link_point</em>&nbsp;</td><td>If this relationship links to something other than the primary table, specify that table here. For example, a 'track' node might have a relationship to an 'album' node, which might have a relationship to an 'artist' node. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="52cdfc5396008424c4c232cca1a8f8bb"></a><!-- doxytag: member="views_query::add_table" ref="52cdfc5396008424c4c232cca1a8f8bb" args="($table, $relationship=NULL, $join=NULL, $alias=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_table           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>relationship</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a table to the query, ensuring the path exists.<p>
This function will test to ensure that the path back to the primary table is valid and exists; if you do not wish for this testing to occur, use $query-&gt;<a class="el" href="classviews__query.html#0ed3905be8cddfdbde96a39569686bcb">queue_table()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The name of the table to add. It needs to exist in the global table array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$relationship</em>&nbsp;</td><td>An alias of a table; if this is set, the path back to this table will be tested prior to adding the table, making sure that all intermediary tables exist and are properly aliased. If set to NULL the path to the primary table will be ensured. If the path cannot be made, the table will NOT be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$join</em>&nbsp;</td><td>In some join configurations this table may actually join back through a different method; this is most likely to be used when tracing a hierarchy path. (node-&gt;parent-&gt;parent2-&gt;parent3). This parameter will specify how this table joins if it is not the default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$alias</em>&nbsp;</td><td>A specific alias to use, rather than the default alias.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>$alias The alias of the table; this alias can be used to access information about the table and should always be used to refer to the table when adding parts to the query. Or FALSE if the table was not able to be added. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88733d15379fa820cc588b11a298a3af"></a><!-- doxytag: member="views_query::add_where" ref="88733d15379fa820cc588b11a298a3af" args="($group, $clause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::add_where           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>clause</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a simple WHERE clause to the query. The caller is responsible for ensuring that all fields are fully qualified (TABLE.FIELD) and that the table already exists in the query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$group</em>&nbsp;</td><td>The WHERE group to add these to; groups are used to create AND/OR sections. Groups cannot be nested. Use 0 as the default group. If the group does not yet exist it will be created as an AND group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$clause</em>&nbsp;</td><td>The actual clause to add. When adding a where clause it is important that all tables are addressed by the alias provided by add_table or ensure_table and that all fields are addressed by their alias wehn possible. Please use d and s for arguments. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A number of arguments as used in <a class="el" href="database_8mysql-common_8inc.html#9e096321b86945d128746ac7bedce8f3">db_query()</a>. May be many args or one array full of args. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9eb7d6626aa24ae83d922cc59682318c"></a><!-- doxytag: member="views_query::adjust_join" ref="9eb7d6626aa24ae83d922cc59682318c" args="($join, $relationship)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::adjust_join           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>relationship</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix a join to adhere to the proper relationship; the left table can vary based upon what relationship items are joined in on. 
</div>
</div><p>
<a class="anchor" name="f36b1f088b20f1d98d23dbf49ee68e97"></a><!-- doxytag: member="views_query::clear_fields" ref="f36b1f088b20f1d98d23dbf49ee68e97" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::clear_fields           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all fields that may've been added; primarily used for summary mode where we're changing the query because we didn't get data we needed. 
</div>
</div><p>
<a class="anchor" name="2048d9a8aefd815a30833b26f6070fb2"></a><!-- doxytag: member="views_query::condition_sql" ref="2048d9a8aefd815a30833b26f6070fb2" args="($where= 'where')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::condition_sql           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>where</em> = <code>'where'</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct the "WHERE" or "HAVING" part of the query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$where</em>&nbsp;</td><td>'where' or 'having'. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2571123727140d93d8ee3357968a626e"></a><!-- doxytag: member="views_query::ensure_path" ref="2571123727140d93d8ee3357968a626e" args="($table, $relationship=NULL, $join=NULL, $traced=array(), $add=array())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::ensure_path           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>relationship</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>traced</em> = <code>array()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>add</em> = <code>array()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make sure that the specified table can be properly linked to the primary table in the JOINs. This function uses recursion. If the tables needed to complete the path back to the primary table are not in the query they will be added, but additional copies will NOT be added if the table is already there. 
</div>
</div><p>
<a class="anchor" name="78c615fc19826e8a640ab27874e2fdaf"></a><!-- doxytag: member="views_query::ensure_table" ref="78c615fc19826e8a640ab27874e2fdaf" args="($table, $relationship=NULL, $join=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::ensure_table           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>relationship</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure a table exists in the queue; if it already exists it won't do anything, but if it doesn't it will add the table queue. It will ensure a path leads back to the relationship table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The unaliased name of the table to ensure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$relationship</em>&nbsp;</td><td>The relationship to ensure the table links to. Each relationship will get a unique instance of the table being added. If not specified, will be the primary table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$join</em>&nbsp;</td><td>A <a class="el" href="classviews__join.html">views_join</a> object (or derived object) to join the alias in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The alias used to refer to this specific table, or NULL if the table cannot be ensured. </dd></dl>

</div>
</div><p>
<a class="anchor" name="de77e3ef670bde3a2eacf8d73f5859fa"></a><!-- doxytag: member="views_query::get_join_data" ref="de77e3ef670bde3a2eacf8d73f5859fa" args="($table, $base_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::get_join_data           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>base_table</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve join data from the larger join data cache.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The table to get the join information for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$base_table</em>&nbsp;</td><td>The path we're following to get this join.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classviews__join.html">views_join</a> object or child object, if one exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4b476ae432575dab501ed30b5421b7d"></a><!-- doxytag: member="views_query::get_table_info" ref="e4b476ae432575dab501ed30b5421b7d" args="($table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::get_table_info           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the information associated with a table.<p>
If you need the alias of a table with a particular relationship, use <a class="el" href="classviews__query.html#78c615fc19826e8a640ab27874e2fdaf">ensure_table()</a>. 
</div>
</div><p>
<a class="anchor" name="caf5f2625a89d8b29e6d9ad6127d1b17"></a><!-- doxytag: member="views_query::get_where_args" ref="caf5f2625a89d8b29e6d9ad6127d1b17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::get_where_args           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the arguments attached to the WHERE and HAVING clauses of this query. 
</div>
</div><p>
<a class="anchor" name="50460c7856f25847d361a45a6c1d4b69"></a><!-- doxytag: member="views_query::query" ref="50460c7856f25847d361a45a6c1d4b69" args="($get_count=FALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::query           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>get_count</em> = <code>FALSE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a query and a countquery from all of the information supplied to the object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$get_count</em>&nbsp;</td><td>Provide a countquery if this is true, otherwise provide a normal query. </td></tr>
  </table>
</dl>

<p>
An optimized count query includes just the base field instead of all the fields. Determine of this query qualifies by checking for a groupby or distinct.
</div>
</div><p>
<a class="anchor" name="0ed3905be8cddfdbde96a39569686bcb"></a><!-- doxytag: member="views_query::queue_table" ref="0ed3905be8cddfdbde96a39569686bcb" args="($table, $relationship=NULL, $join=NULL, $alias=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::queue_table           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>relationship</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>join</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a table to the query, without ensuring the path.<p>
This function will test to ensure that the path back to the primary table is valid and exists; if you do not wish for this testing to occur, use $query-&gt;<a class="el" href="classviews__query.html#0ed3905be8cddfdbde96a39569686bcb">queue_table()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$table</em>&nbsp;</td><td>The name of the table to add. It needs to exist in the global table array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$relationship</em>&nbsp;</td><td>The primary table alias this table is related to. If not set, the primary table will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$join</em>&nbsp;</td><td>In some join configurations this table may actually join back through a different method; this is most likely to be used when tracing a hierarchy path. (node-&gt;parent-&gt;parent2-&gt;parent3). This parameter will specify how this table joins if it is not the default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$alias</em>&nbsp;</td><td>A specific alias to use, rather than the default alias.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>$alias The alias of the table; this alias can be used to access information about the table and should always be used to refer to the table when adding parts to the query. Or FALSE if the table was not able to be added. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b669461223ddaae12248f28b4ccfb525"></a><!-- doxytag: member="views_query::set_count_field" ref="b669461223ddaae12248f28b4ccfb525" args="($table, $field, $alias=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::set_count_field           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>alias</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set what field the query will count() on for paging. 
</div>
</div><p>
<a class="anchor" name="cb3f17ef4ae3d80a44ee7b6962165247"></a><!-- doxytag: member="views_query::set_distinct" ref="cb3f17ef4ae3d80a44ee7b6962165247" args="($value=TRUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::set_distinct           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>TRUE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the base field to be distinct. 
</div>
</div><p>
<a class="anchor" name="8dfc6f355b29f697401f0dc7f7aa82a1"></a><!-- doxytag: member="views_query::set_group_operator" ref="8dfc6f355b29f697401f0dc7f7aa82a1" args="($type= 'AND')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::set_group_operator           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>'AND'</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Control how all WHERE and HAVING groups are put together.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$type</em>&nbsp;</td><td>Either 'AND' or 'OR' </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="83e8dfa6c88442e0f34b00d467f3b35e"></a><!-- doxytag: member="views_query::set_header" ref="83e8dfa6c88442e0f34b00d467f3b35e" args="($header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::set_header           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>header</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the table header; used for click-sorting because it's needed info to modify the ORDER BY clause. 
</div>
</div><p>
<a class="anchor" name="7c803401b485f379a93688efd7aa2886"></a><!-- doxytag: member="views_query::set_where_group" ref="7c803401b485f379a93688efd7aa2886" args="($type= 'AND', $group=NULL, $where= 'where')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::set_where_group           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>'AND'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>group</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>where</em> = <code>'where'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new grouping for the WHERE or HAVING clause.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>$type</em>&nbsp;</td><td>Either 'AND' or 'OR'. All items within this group will be added to the WHERE clause with this logical operator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$group</em>&nbsp;</td><td>An ID to use for this group. If unspecified, an ID will be generated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>$where</em>&nbsp;</td><td>'where' or 'having'.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>$group The group ID generated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa6130b3c7d7a5a5edb03069bb7d8995"></a><!-- doxytag: member="views_query::views_query" ref="fa6130b3c7d7a5a5edb03069bb7d8995" args="($base_table= 'node', $base_field= 'nid')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::views_query           </td>
          <td>(</td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>base_table</em> = <code>'node'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">$&nbsp;</td>
          <td class="paramname"> <em>base_field</em> = <code>'nid'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor; Create the basic query object and fill with default values. 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="48c0f8c68da79257d96109835021305c"></a><!-- doxytag: member="views_query::$distinct" ref="48c0f8c68da79257d96109835021305c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$distinct = FALSE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A flag as to whether or not to make the primary field distinct. 
</div>
</div><p>
<a class="anchor" name="a290c68d4f2fd7ccc73219ce5e57d0f7"></a><!-- doxytag: member="views_query::$group_operator" ref="a290c68d4f2fd7ccc73219ce5e57d0f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$group_operator = 'AND'          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default operator to use when connecting the WHERE groups. May be AND or OR. 
</div>
</div><p>
<a class="anchor" name="9e680695793121eceb7da5e5f8f0105a"></a><!-- doxytag: member="views_query::$groupby" ref="9e680695793121eceb7da5e5f8f0105a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$groupby = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A simple array of group by clauses. 
</div>
</div><p>
<a class="anchor" name="a63f09e8b8810660bbc0c480f763c8a7"></a><!-- doxytag: member="views_query::$having" ref="a63f09e8b8810660bbc0c480f763c8a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$having = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An array of sections of the HAVING query. Each section is in itself an array of pieces and a flag as to whether or not it should be AND or OR. 
</div>
</div><p>
<a class="anchor" name="8c8dc5000b07e8a5ade3691ddabecbc3"></a><!-- doxytag: member="views_query::$header" ref="8c8dc5000b07e8a5ade3691ddabecbc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$header = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The table header to use for tablesort. This matters because tablesort needs to modify the query and needs the header. 
</div>
</div><p>
<a class="anchor" name="03a5999bf0fcd2bd5a51dfea6c78ebdb"></a><!-- doxytag: member="views_query::$orderby" ref="03a5999bf0fcd2bd5a51dfea6c78ebdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$orderby = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A simple array of order by clauses. 
</div>
</div><p>
<a class="anchor" name="deed5f6f13a7d105ada7c1329c3169d6"></a><!-- doxytag: member="views_query::$relationships" ref="deed5f6f13a7d105ada7c1329c3169d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$relationships = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Holds an array of relationships, which are aliases of the primary table that represent different ways to join the same table in. 
</div>
</div><p>
<a class="anchor" name="209ff1ef3916cfbdfc70560e567a9cc0"></a><!-- doxytag: member="views_query::$table_queue" ref="209ff1ef3916cfbdfc70560e567a9cc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$table_queue = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A list of tables in the order they should be added, keyed by alias. 
</div>
</div><p>
<a class="anchor" name="cec1482297b871cac1fddcef0a0e8ab1"></a><!-- doxytag: member="views_query::$tables" ref="cec1482297b871cac1fddcef0a0e8ab1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$tables = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Holds an array of tables and counts added so that we can create aliases 
</div>
</div><p>
<a class="anchor" name="2654e7db457f1b7ec34ca1ac3345fc83"></a><!-- doxytag: member="views_query::$where" ref="2654e7db457f1b7ec34ca1ac3345fc83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">views_query::$where = array()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An array of sections of the WHERE query. Each section is in itself an array of pieces and a flag as to whether or not it should be AND or OR. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>sites/all/modules/contrib/views/includes/<a class="el" href="query_8inc.html">query.inc</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Feb 12 18:59:52 2011 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
